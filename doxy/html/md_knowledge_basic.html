<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Pink_server_doxygen: 基础知识</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Pink_server_doxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">基础知识 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><hr/>
<h4>服务器并发模式分析</h4>
<p><b>1. 单进程多线程模式</b></p>
<p>通过在单进程内创建线程池，使工作线程异步并行地为客户的请求服务。</p>
<p><b>优点：</b></p>
<p>（1）工作线程之间数据共享方便（全局、静态变量）。</p>
<p>（2）线程的上下文切换开销较小（不切换地址空间，不刷新 TLB，只修改部分 CPU 寄存器），善于处理高并发。</p>
<p>（3）线程创建速度较快。</p>
<p><b>缺点：</b></p>
<p>（1）一个线程挂了，其他线程也就挂了。（虽然能写守护进程来重启，但是会有宕机期。）</p>
<p>（2）编程时需要考虑资源的同步问题，稍显复杂。</p>
<p><b>2. 多进程单线程模式</b></p>
<p><b>优点：</b></p>
<p>（1）一个进程崩溃可以被 master 重启，并不会使整个服务器挂掉。因此 master 安全隔离了工作进程。</p>
<p>（2）数据隔离和错误隔离。</p>
<p>（3）编程相对简单，通常不同考虑资源同步的问题。</p>
<p><b>缺点：</b></p>
<p>（1）进程切换开销大，对高并发的处理能力不如多线程模式。</p>
<p><b>3. 多进程多线程模式</b></p>
<p>在每个子进程内开多个线程。在支持高并发的情况下，避免了单进程多线程的宕机问题。</p>
<p><b>4. Pink server 的模式</b></p>
<p>目前的 Pink 为单进程多线程模式（更像单进程版的 Apache event MPM 模式）。实现这个模式一是为了熟悉多线程编程、资源同步方式，二是觉得从多线程到多进程的过度相对容易。（下一个 server 实现多进程。） </p><hr/>
<h4>主流的 Web 服务器分析</h4>
<p><b>1. Apache</b></p>
<p>Apache 有三种稳定的 MPM（multi-processing module），即多进程处理模块。分别是 prefork、worker和 event。</p>
<p>（1）prefork（Linux 下的默认模式）</p>
<p>很古老但十分稳定。通过预先 fork 一些子进程等待请求。一个子进程一个线程，处理一个请求。</p>
<p>优点：不需要考虑线程安全问题。成熟稳定。</p>
<p>缺点：子进程数量有上限，不能 handle 高并发的情况。进程的内存开销大。</p>
<p>（2）worker</p>
<p>在 prefork 的基础上，每个子进程中创建多个线程。（这里使用多进程是为了服务器的稳定性。）</p>
<p>优点：高并发下比 prefork 更优秀，占据更少内存。</p>
<p>缺点：由于用了多线程，则需要考虑线程安全问题。</p>
<p>（3）event</p>
<p>把工作线程和连接分离开来，从而解决 keep-alive 连接总是占据一个工作线程的问题。以事件的形式触发线程。（基于 linux epoll）</p>
<p>优点：处理了 keep-alive 连接的情况。更高的并发量。事件驱动使得更适合于 IO 密集型服务。</p>
<p>缺点：对于 HTTPS 连接，仍然是类似 worker 模式，线程会一直被占用的。</p>
<p><b>2. Tomcat</b></p>
<p>Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器。由于技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的 Web 应用服务器。</p>
<p>实际上Tomcat是Apache 服务器的扩展，但运行时它是独立运行的，所以当你运行tomcat 时，它实际上作为一个与Apache 独立的进程单独运行的。</p>
<div class="image">
<img src="../imgs/tomcat_structure.png"/>
</div>
<p><b>3. NginX</b></p>
<p>参考1：https://www.jianshu.com/p/a253d21e4b16</p>
<p>参考2（阿里云天基blog）：http://tengine.taobao.org/book/#id4</p>
<p>轻量级的异步非阻塞高性能 HTTP/ 反向代理 服务器。（也可以作为邮件服务器）</p>
<p><b>1. Structure:</b></p>
<div class="image">
<img src="../imgs/nginx_structure.png"/>
</div>
<p><b>2. Work flow:</b></p>
<p>（1）master进程会接收来自外界发来的信号，再根据信号做不同的事情。</p>
<p>（2）在master进程里面，先建立好 listenfd 之后，然后再 fork 出多个 worker 进程。</p>
<p>（3）为保证只有一个进程处理该连接，所有 worker 进程事先抢 accept_mutex，抢到互斥锁的那个进程注册 listenfd 读事件，在读事件里调用 accept 接受该连接。</p>
<p>（4）worker 读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接一个请求，完全由 worker 进程来处理，而且只在一个 worker 进程中处理。（worker 进程之间互不影响。）</p>
<p>（5）</p>
<p><b>3. Features:</b></p>
<p>（1) 多进程，分为 master 和多个 worker 进程。</p>
<p>（2）每个进程单线程，因此省去了线程切换的开销，可以看成单线程循环处理一系列准备好的任务，十分高效。</p>
<p>（3）定时器处理方法：每次 epoll_wait 的超时时间设置为最近要超时的定时器到现在的时间差。</p>
<p>伪代码（逻辑为先处理 task 任务，再处理超时任务，最后 epoll）： </p><div class="fragment"><div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div><div class="line">    <span class="keywordflow">for</span> t in run_tasks:</div><div class="line">        t.handler();</div><div class="line">    update_time(&amp;now);</div><div class="line">    timeout = ETERNITY;</div><div class="line">    <span class="keywordflow">for</span> t in wait_tasks: <span class="comment">/* sorted already */</span></div><div class="line">        <span class="keywordflow">if</span> (t.time &lt;= now) {</div><div class="line">            t.timeout_handler();</div><div class="line">        } <span class="keywordflow">else</span> {</div><div class="line">            timeout = t.time - now;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    nevents = poll_function(<a class="code" href="pink__epoll_8cpp.html#a18bcd14e4d4cab5184d3b046754cd248">events</a>, timeout);</div><div class="line">    <span class="keywordflow">for</span> i in nevents:</div><div class="line">        task t;</div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="pink__epoll_8cpp.html#a18bcd14e4d4cab5184d3b046754cd248">events</a>[i].type == READ) {</div><div class="line">            t.handler = read_handler;</div><div class="line">        } <span class="keywordflow">else</span> { <span class="comment">/* events[i].type == WRITE */</span></div><div class="line">            t.handler = write_handler;</div><div class="line">        }</div><div class="line">        run_tasks_add(t);</div><div class="line">}</div></div><!-- fragment --><p>（4）解析 HTTP 请求报文中的 method 时，将四个字符转换成一个整型，然后一次比较以减少cpu的指令数。</p>
<p><b>4. Components:</b></p>
<p>（1）ngx_connection_t</p>
<p>对tcp连接的封装，其中包括连接的socket，读事件，写事件。建立连接，发送与接受数据。</p>
<p>worker_connections</p>
<p>（2）ngx_http_request_t</p>
<p>（3）ngx_pool_t</p>
<p>（4）ngx_array_t</p>
<p>ngx_hash_t</p>
<p>ngx_hash_wildcard_t</p>
<p>ngx_hash_combined_t</p>
<p>ngx_hash_keys_arrays_t</p>
<p>ngx_chain_t</p>
<p>ngx_buf_t</p>
<p>ngx_list_t</p>
<p>ngx_queue_t</p>
<p>nginx.conf</p>
<p><b>5. Advantages:</b></p>
<p>（1）轻量级，比 apache 占用更少的内存资源。</p>
<p>（2）高度模块化的设计。</p>
<p>（3）性能强大，静态处理性能比 apache 高三倍以上。</p>
<hr/>
<h4>HTTP 1.0、HTTP 1.1、HTTP 2.0</h4>
<p>参考1：https://www.cnblogs.com/heluan/p/8620312.html</p>
<ol type="1">
<li>HTTP 1.0（1996)</li>
<li>HTTP 1.1（1999)</li>
</ol>
<p>比 1.0 版本多了：</p>
<p>（1）**缓存处理**，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的**缓存头**来控制缓存策略。</p>
<p>（2）**带宽优化及网络连接的使用**，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且**不支持断点续传**功能，HTTP1.1则在请求头引入了**range头域**，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p>
<p>（3）**错误通知的管理**，在HTTP1.1中新增了24个**错误状态响应码**，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p>
<p>（4）**Host头处理**，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且**请求消息中如果没有Host头域会报告一个错误**（400 Bad Request）。</p>
<p>（5）**长连接**，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启**Connection： keep-alive**，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p>
<ol type="1">
<li>HTTP 2.0（2015）</li>
</ol>
<p>基于 google 2012 年提出的 SPDY 设计的。</p>
<p>（1）**新的二进制格式（Binary Format）**，HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</p>
<p>（2）**多路复用（MultiPlexing）**，即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。(<b>More</b>: HTTP/2引入二进制数据帧和流的概念，其中帧对数据进行顺序标识，如下图所示，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。)</p>
<p>（3）**header压缩**，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</p>
<p>（4）**服务端推送（server push）**，实现了类似SPDY的功能：采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。</p>
<p><b>多路复用带来的优化：</b></p>
<p>HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。 HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。</p>
<div class="image">
<img src="../imgs/HTTP2.0.jpeg"/>
</div>
 <hr/>
<h4>HTTP Web 服务器基础概念</h4>
<div class="image">
<img src="../imgs/http_web_server.png"/>
</div>
<p>（1）建立连接</p>
<p>（2）接收请求（从网络中读取HTTP请求报文）</p>
<p>（3）处理请求（对请求报文进行解释，并采取行动）</p>
<p>（4）访问资源（访问报文中指定的资源）</p>
<p>（5）构建响应（创建带有正确首部的HTTP响应报文）</p>
<p>（6）发送响应（将响应回送给客户端）</p>
<p>（7）记录事务处理过程（将与已完成事务有关的内容记录在一个日志文件中） </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
