@startuml

participant 客户端

participant 监听socket

participant 内核缓冲区

participant 连接池

participant epoll

participant 定时器时间堆

participant 线程池工作队列

participant 工作线程

监听socket -> epoll : 注册就绪事件

客户端 -> 监听socket : TCP连接请求

监听socket -> epoll : 连接就绪

epoll -> 客户端 : accept连接

epoll -> 连接池 : 请求连接体指针

连接池 -> 连接池 : 获取链表表头连接体\n指针，线程安全

连接池 -> epoll : 返回连接体指针

epoll -> epoll : 注册该连接的读就绪事件

epoll -> 定时器时间堆 : 插入该连接\n的定时器

客户端 -> 内核缓冲区 : 发送HTTP请求报文

内核缓冲区 -> epoll : 缓冲区可读

epoll -> 定时器时间堆 : 更新该连接\n定时器的超时时间

epoll -> 线程池工作队列 : 发送读取任务

线程池工作队列 -> 线程池工作队列 : (1)互斥锁加锁 (2)插入读取任务\n(3) 互斥锁解锁

线程池工作队列 -> 工作线程 : 触发信号量，通知

内核缓冲区 -> 工作线程: 非阻塞读入数据到用户缓冲区

工作线程 -> 工作线程 : HTTP状态机\n处理请求

工作线程 --[#green]> epoll : 如果非阻塞读入不完整 (EAGAIN)，注册读就绪事件

客户端 --[#green]> 内核缓冲区 : 继续发送剩余的HTTP请求报文

内核缓冲区 --[#green]> epoll : 缓冲区可读

epoll --[#green]> 定时器时间堆 : 更新该连接\n定时器的超时时间

epoll --[#green]> 线程池工作队列 : 发送读取任务

线程池工作队列 --[#green]> 线程池工作队列 : (1)互斥锁加锁 (2)插入读取任务\n(3) 互斥锁解锁

线程池工作队列 --[#green]> 工作线程 : 触发信号量，通知

工作线程 --[#green]> 工作线程 : HTTP状态机\n继续处理请求

工作线程 -> 客户端 : 读入的HTTP请求完整，写出HTTP响应报文

工作线程 --[#blue]> epoll : 如果非阻塞写出不完整 (EAGAIN)，注册写就绪事件

内核缓冲区 --[#blue]> epoll : 缓冲区可写

epoll --[#blue]> 线程池工作队列 : 发送写任务

线程池工作队列 --[#blue]> 线程池工作队列 : (1)互斥锁加锁 (2)插入读取任务\n(3) 互斥锁解锁

线程池工作队列 --[#blue]> 工作线程 : 通知

工作线程 --[#blue]> 客户端 : 继续写出HTTP响应报文 ...

==HTTP请求报文中Connection: close==

工作线程 -> epoll : 删除epoll该连接的 fd

工作线程 -> 工作线程 : 关闭该连接\n的 fd

工作线程 -> 连接池 : 放回该连接体指针

连接池 -> 连接池 : 插入连接体指针到表尾，\n线程安全

==处理非活动连接的超时事件==

epoll -> 定时器时间堆 : 定期检查时间堆

定时器时间堆 -> 定时器时间堆 : 弹出超时的定时器，\n运行回调函数，\n关闭对应连接fd

定时器时间堆 -> 连接池 : 放回该连接体指针

连接池 -> 连接池 : 插入连接体指针到表尾，\n线程安全

@enduml